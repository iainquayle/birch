\documentclass{article}

\title{Birch Language Specification}

\setlength{\parindent}{0pt}
\begin{document}
	\maketitle
	\newpage
	\section{Purpose}
	\section{Overview}
		\paragraph{Modules}
			Modules define all structural scope in Birch. 
			Any Birch file is a module, and any public module may be imported by any other module using the import keyword.
			Modules also can define data structures, which is dicussed in User Defined Types.
		\paragraph{User Defined Types}
			\subparagraph{Modules}
				Any module may have an internal data structure defined, which will always be an algebraic type.
				If a module has a data structure, it may be instantiated.
				(If tuples removed, then modules will need destructuring syntax)
			\subparagraph{Tuples (and Structs?)}
				Tuples may be prototyped, and elements given names. 
				A function returning a tuple, may also give names to the elements of the tuple, without prototyping the tuple ahead of time.
				Elements may be accessed by name or index.
				Tuples may be automatically destructured at which point there will be no
				(Depending on how stream lined modules become, perhaps tuples will be removed entirely)
		\paragraph{Functions}
	\section{Tokens}
		\subsection{Key Words}
			\begin{tabular}{rl}
				\texttt{use} & USE\\
				\texttt{fn} & FN\\
				\texttt{with} & WITH\\
				\texttt{let} & LET\\
				\texttt{priv} & PRIV\\
				\texttt{vis} & VIS\\
				\texttt{pub} & PUB\\
				\texttt{if} & IF\\
				\texttt{else} & ELSE\\ 
				\texttt{match or case} & \\
				\texttt{for} & FOR\\
				\texttt{while} & WHILE\\
				\texttt{mod} & MOD\\
				\texttt{type} & TYPE \\
				\texttt{to} & TO\\
				\texttt{as} & AS\\
				\texttt{unsafe} & UNSAFE\\
				\texttt{self} & \\
				\texttt{Self} & \\
			\end{tabular}
		\subsection{Symbols}
			\begin{tabular}{rl}
				\texttt{+} & ADD\\
				\texttt{-} & SUB\\
				\texttt{*} & MUL\\
				\texttt{/} & DIV\\
				\texttt{\%} & MOD\\
				\texttt{\&} & AND\\
				\texttt{|} & OR\\
				\texttt{\^} & XOR\\
				\texttt{<<} & L\_SHIFT\\
				\texttt{>>} & R\_SHIFT\\
				\texttt{\&\&} & S\_AND\\
				\texttt{||} & S\_OR\\
				\texttt{==} & EQ\\
				\texttt{!=} & NEQ\\
				\texttt{<} & LT\\
				\texttt{>} & GT\\
				\texttt{<=} & LTE\\
				\texttt{>=} & GTE\\
				\texttt{!} & NOT\\
				\texttt{=} & ASSIGN\\
				\texttt{|>} & PIPE\\
				\texttt{->} & R\_ARROW\\
				\texttt{=>} & R\_FAT\_ARROW\\
				\texttt{<-} & L\_ARROW\\
				\texttt{<=} & L\_FAT\_ARROW\\
				\texttt{[} & L\_BRACKET\\
				\texttt{]} & R\_BRACKET\\
				\texttt{(} & L\_PAREN\\
				\texttt{)} & R\_PAREN\\
				\texttt{\{} & L\_BRACE\\
				\texttt{\}} & R\_BRACE\\
				\texttt{;} & SEMI\\
				\texttt{,} & COMMA\\
				\texttt{.} & DOT\\
				\texttt{..} & RANGE\\
				\texttt{:} & COLON\\
				\texttt{?} & OPTION\\
			\end{tabular}
		\subsection{Types}	
			\begin{tabular}{rl}
				\texttt{u(8 | 16 | 32 | 64)} & UINT\_(num)\\
				\texttt{u(8 | 16 | 32 | 64)} & INT\_(num)\\
				\texttt{u(8 | 16 | 32 | 64)}  & FLOAT\_(num)\\
				\texttt{usize} & USIZE\\ 
			\end{tabular}
		\subsection{Constants}
			\begin{tabular}{rl}
				\texttt{[0-9]*} & CONST\_INT\\
				\texttt{[0-9]?.[0-9]*} & CONST\_FLOAT\\
			\end{tabular}
		\subsection{Identifiers}
			\begin{tabular}{rl}
				\texttt{[a-zA-Z\_][a-zA-Z0-9\_]*} & IDENT\\
			\end{tabular}	
	\section{Grammar}
		

		prog
			mod\_list main 
		decl\_list
			decl decl\_list 
		decl 
\end{document}

