\documentclass{article}

\title{Birch Language Specification}

\setlength{\parindent}{0pt}
\begin{document}
	\maketitle
	\newpage
	\section{Purpose}
		Birch sets out to be a language that merges the best of functional and OOP into one style,
		rather than merely supporting both paradigms,
		cutting down the breadth of possible ways to write a given piece of code.
		Statically typed, AOT compiled, and as minimal as possible while being reasonably safe.
	\section{Overview}
		\paragraph{Modules}
			Modules define all structural scope in Birch. 
			Any Birch file is a module, and any public module may be imported by any other module using the import keyword.
			Modules also can define data structures, which is dicussed in User Defined Types.
		\paragraph{User Defined Types}
			\subparagraph{Modules}
				Any module may have an internal data structure defined, which will always be an algebraic type.
				If a module has a data structure, it may be instantiated.
				(If tuples removed, then modules will need destructuring syntax)
			\subparagraph{Tuples}
				Tuples may be prototyped, and elements given names. 
				A function returning a tuple, may also give names to the elements of the tuple, with out prototyping the tuple ahead of time.
				Elements may be accessed by name or index.
				Tuples may be automatically destructured, which will not preserve the element names.
				(Depending on how stream lined modules become, perhaps tuples will be removed entirely)
			\subparagraph{Aliasing}
				Any type may be aliased, though no further functionality will be added to the type.
		\paragraph{Functions}
	\section{Types}	
		u8-64\\
		i8-32\\
		f32-64\\
		usize\\ 
		Future specifications would add homogenous vector types that will natively support SIMD operations.
	\section{Reserved Words}
		let\\
		priv\\
		expose\\
		import\\
		pub\\
		if\\
		else\\ 
		match or case tbd\\
		for\\
		while\\
		mod\\
		data or type tbd\\
		tup may not be needed depending on how type is implemented\\ 
		to\\
		as\\
		unsafe or trust (may just replace with tight c interface integration?)\\
		none\\
		self\\
		Self\\
	\section{Operators}
		$.$
		$.=$
		$+ - * / | \& \^$
		$(op from above)=$
		$<, >, =$
		$(op from above)=$
	\section{Symbols}
		$[ ]
		( )
		{ }
		' "
		\: ;
		? \_$

	\section{Tokens}
		

	\section{Grammar}
		prog
			mod\_list main 
		decl\_list
			decl decl\_list 
		decl 
\end{document}

