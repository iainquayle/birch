types: 
	u8-64,
	i8-i32,
	f32,
	f64,
	usize 
reserved words:
	let, 
	priv,
	pub,
	if, 
	else, 
	match or case tbd,
	for,
	while,
	mod,
	data or type tbd,  
	tup may not be needed depending on how type is implemented, 
	to,
	as,
	unsafe or trust,
	none,
	self, 
	Self,
operators:
	.
	.=
	+ - * / | & ^
	(op from above)=
	<, >, =
	(op from above)=
symbols:
	[ ]
	( )
	{ }
	' "
	: ;
	? _

tokens:
	

grammar:
	prog: mod_list main 
	decl_list: decl decl_list |  
	decl: 

notes:
	for consideration, making some form of packed data that is native to the language 
	consider making it such that the / op actually just makes a num effectivley 1/x
	figure out scoping symbol useage 
	may change it such that modules can be compiled at run time, in which case the syntax for a mod would change to
		mod _ = ...
	perhaps files wont be treated as modules, thus importing the explicit module will be required 
	will need to resolve the piping idea with the .= operation
	consider making the top level mod in a file, if the only one, not require any scoping, maybe signify it as such some how 
	modules and funcions are pre annotated



	mod 
		data Self = 
			x: i32 

	mod 
		data Self = 
			& 
				x: i32 
				h: i32
			SomeType | 
				y: i32
				z: i32
			OtherType | 
				y: i32
				z: i32

	
		func f(self)

		...
			type =, 1, 1 -> f -> ...

