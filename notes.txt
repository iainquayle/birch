what if for types it more along the lines of elixir/ts where types are trivial to define as an inline
suppose fn(...) -> some: i16 | none ...
in this case, simple enum variants just dont get any type, when matching, they cant have anything taken from them
suppose fn(...) -> ok: i16 | err: u16 ...
suppose fn(...) -> one: i16 | two: {x: u16, y: u16} ...
even perhaps being able to switch on the existense of a certain member?
where it could be that the options are allowed to run into the children of a structure
these types would also be equivlent based on structure and iternal names rather than the name of the type?
while this would hypothetically get rid of the need for generics,
it would likely make that a complete pain in the ass if the generic type had any size to it.
this could be simply over come with a more simplistic macros system?
at the end of the day generics arent absolutly necessary, but the flexibility of arithmatic types is a big plus
then when writing a switch, write out the part of the structure that you want to match on, ie for the last example
| one -> ...
| two: {x, y} -> ... or | two -> ...
in the case of a nested arithmatic, could then just match on the super name of it, and create a whole new nested switch, or,
enumerate all the possible structures in one switch statement.

as well, type classes need to be flushed out,
it would be nice to even be able to add to an existing type class definition, ie? though this could be too problematic


figure out scoping symbol useage 
may change it such that modules can be compiled at run time, in which case the syntax for a mod would change to
	mod \_ = ...
perhaps files wont be treated as modules, thus importing the explicit module will be required 
consider making the top level mod in a file, if the only one, not require any scoping, maybe signify it as such some how 
modules and funcions are pre annotated


the idea for generic function prototypes will be the means to traits, how to make collections of them though? unless just dont 

change so that environment capture is allowed


also, what about making paraenthesis essentially a scoped code block, and allowing multiple statements inside?
paras for running code, curly for structuring data, and square for indexing?
this could be an issue though, suppose in the case of functions, there is code that is not ran until called? as versus paras which are ran immediately
	that it self could the the factor? may also be the case that functions dont need explicit scoping, though that likely woulnt work for the case of nested functions
may not need any brackets for generics, it could even be the case that macros get their own identifiable brackets



mod 
	data Self = 
		x: i32 

mod 
	data Self = 
			x: i32 
			h: i32
		| SomeType 
			y: i32
			z: i32
		| OtherType 
			y: i32
			z: i32


	func f(self)

	...
		type =, 1, 1 -> f -> ...


members, modules, and functions can be access restricted to the module they are defined in, perhaps as well selectively to other modules


so an example of a module, take the shape types used in lemnos

mod Shape
	pub type Shape =
			shape: [u32, 3] //assuming it is max 3d
			vis dims: u32
		| Locked
		| Open

	pub fn common_lossless ... -> ? Shape:
		...

pub type Option T = 
	| Some
		value: T
	| None

pub type Tree T = 
	| Node
		value: T,
		left: Tree T,
		right: Tree T
	| Leaf

	OR...

		value: T
		left: (Tree T)
		right: (Tree T)

pub type Option T B ...something Trait = 

perhaps the switch between inlined types and allocated types can just be handled by the compiler,
	it should be obvious enough for the user when the compiler will do it (maybe can have some decorator that will crash if it happens)

can also allow optional names, such that if there is one name, they are all required, but if none thats fine

regarding how to do visibility
	make an impl type block, which would allow funcs to be kind of scoped and what not the types, and as well make for easy extensibility
		though, at that point, its more like a class
	make name spaces type modules, where any type defined in that namespace has visibility restricted to it
	the other other option, is make it less flexible, and only allow traits to be defined outside of the scoping module? this also dont seen right
	perhaps instead of modules, make a "space", but then organization is harder
	
	PERHAPS, best is still to be like elixir, and have modules that can be defined anywhere?
		make types defined in a module, then a module with by the same name, will have the correct visibilities

	type Shape = ...
	mod Shape
		...

for traits, which are effectivley just function patterns/prototypes/whatever, no need to copy the whole thing, can do something like impl ...
	then for the inputs, allow it to just be described as "inputs" or "arguments" and access the already described args as inputs.arg_name 

could there be some way to create some one off, or few off datastructure and then attach functionality directly to it rather than needing to do a lookup?



the mashability of structs/tuples could cause issues so rules need to be established:
	eager
		piping is eager, ie  _ , _ |> func, _ |> func is ((_, _) |> func, _) |> func
		thus to pipe two results into a func
		(_, _ |> func), (_ |> func) |> func
		function overloading would be nice, but with this, could be very dangerous, so it may need to be tossed
		probably also dont need to the , delimiter
	tuple piping
		can pip items into a tuple
		ie x y |> _ _ z is (x, y, z)
		
