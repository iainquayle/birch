figure out scoping symbol useage 
may change it such that modules can be compiled at run time, in which case the syntax for a mod would change to
	mod \_ = ...
perhaps files wont be treated as modules, thus importing the explicit module will be required 
consider making the top level mod in a file, if the only one, not require any scoping, maybe signify it as such some how 
modules and funcions are pre annotated


the idea for generic function prototypes will be the means to traits, how to make collections of them though? unless just dont 

change so that environment capture is allowed

mod 
	data Self = 
		x: i32 

mod 
	data Self = 
			x: i32 
			h: i32
		| SomeType 
			y: i32
			z: i32
		| OtherType 
			y: i32
			z: i32


	func f(self)

	...
		type =, 1, 1 -> f -> ...


members, modules, and functions can be access restricted to the module they are defined in, perhaps as well selectively to other modules


so an example of a module, take the shape types used in lemnos

mod Shape
	pub type Shape =
			shape: [u32, 3] //assuming it is max 3d
			vis dims: u32
		| Locked
		| Open

	pub fn common_lossless ... -> ? Shape:
		...

pub type Option T = 
	| Some
		value: T
	| None

pub type Tree T = 
	| Node
		value: T,
		left: Tree T,
		right: Tree T
	| Leaf

	OR...

		value: T
		left: (Tree T)
		right: (Tree T)

pub type Option T B ...something Trait = 

perhaps the switch between inlined types and allocated types can just be handled by the compiler,
	it should be obvious enough for the user when the compiler will do it (maybe can have some decorator that will crash if it happens)

can also allow optional names, such that if there is one name, they are all required, but if none thats fine

regarding how to do visibility
	make an impl type block, which would allow funcs to be kind of scoped and what not the types, and as well make for easy extensibility
		though, at that point, its more like a class
	make name spaces type modules, where any type defined in that namespace has visibility restricted to it
	the other other option, is make it less flexible, and only allow traits to be defined outside of the scoping module? this also dont seen right
	perhaps instead of modules, make a "space", but then organization is harder
	
	PERHAPS, best is still to be like elixir, and have modules that can be defined anywhere?
		make types defined in a module, then a module with by the same name, will have the correct visibilities

	type Shape = ...
	mod Shape
		...


